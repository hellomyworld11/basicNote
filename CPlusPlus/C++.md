### C

```c
1. ## 运算符
示例：#define EXAMPLE(n) x##n  ->   EXAMPLE(4)  x4
```



### C++对象模型

****

被弃用的特性
```C++
	

```





### C++知识点

#### 1.const

```
1. 修饰的变量不能再改变
2. 指向常量的指针(const char *p)  指针常量(char const *p)
3. 常量引用 
4. int getValue() const;  说明该函数不能修改成员变量
5. 修饰类成员变量 只能在初始化列表赋值 (引用类型的成员变量也需要初始化列表赋值)
延伸：
constexpr  常量表达式
```

#### 2.static

```
1.修饰局部变量，修改其存储区域和生存周期
2.修改全局函数，使其只能在此文件中使用
3.静态成员函数、成员变量 
```

#### 3.this

```
1.隐藏于非静态成员函数中 ，指向具体的对象
```

4.用的少的关键字 & 描述符

```
1.
#pragma pack(n) 使用n字节对齐
2. 
decltype()  类型检查
```

右值引用

```
绑定右值(临时对象，将要销毁的对象)的引用。一般表示对象的值
可以实现 传递语义和精确传递
作用 ：
消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率
```

多态  虚函数 注意

```
编译时多态： 函数重载
运行时多态   虚函数：用 virtual 修饰成员函数，使其成为虚函数
！构造函数不能是虚函数 此时还没有虚指针
！虚析构函数
	基类的指针指向派生类对象时，delete时 能调用子类对象析构函数 防止内存泄漏
```

内存管理

```
如何定义一个只能在堆上（栈上）生成对象的类？
堆上： 析构函数私有
栈上： 重载私有化new 和delete
```

！智能指针

```
 #include <memory>

1.shared_ptr  共享对象  计数
2 unique_ptr  独占式
3 weak_ptr   共享但不拥有
4.auto_ptr 弃用
```

强制类型转换

```
1.static_cast
	非多态类型的转换   子类向上转换(隐式) 安全  父类向下转换不安全
2.dynamic_cast
	多态类型的转换   类型检查
3.const_cast
	用于删除 const、volatile特性
4.reinterpret_cast
用于位的解释

```

